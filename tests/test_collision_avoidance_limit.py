"""Module for testing collision avoidance limits in configuration limits."""

import itertools

import mujoco
import numpy as np
from absl.testing import absltest
from robot_descriptions.loaders.mujoco import load_robot_description

from mink import Configuration
from mink.limits import CollisionAvoidanceLimit
from mink.limits.collision_avoidance_limit import (
    Contact,
    compute_contact_normal_jacobian,
)
from mink.utils import get_body_geom_ids


class TestCollisionAvoidanceLimit(absltest.TestCase):
    """A class for testing the CollisionAvoidanceLimit functionality."""

    @classmethod
    def setUpClass(cls):
        """Load the robot model for testing."""
        cls.model = load_robot_description("ur5e_mj_description")

    def setUp(self):
        """Initialize the configuration for each test."""
        self.configuration = Configuration(self.model)
        self.configuration.update_from_keyframe("home")

    def test_dimensionality_of_constraints(self):
        """Test the dimensionality of the constraints generated by CollisionAvoidanceLimit."""
        geom1_ids = get_body_geom_ids(self.model, self.model.body("wrist_2_link").id)
        geom2_ids = get_body_geom_ids(self.model, self.model.body("upper_arm_link").id)

        bound_relaxation = -1e-3
        collision_limit = CollisionAvoidanceLimit(
            model=self.model,
            geom_pairs=[(geom1_ids, geom2_ids)],
            bound_relaxation=bound_relaxation,
        )

        # Filter out geoms that are not set to collide
        colliding_geom1_ids = [
            g for g in geom1_ids if self.model.geom_conaffinity[g] and self.model.geom_contype[g]
        ]
        colliding_geom2_ids = [
            g for g in geom2_ids if self.model.geom_conaffinity[g] and self.model.geom_contype[g]
        ]
        expected_max_contacts = len(list(itertools.product(colliding_geom1_ids, colliding_geom2_ids)))

        self.assertEqual(collision_limit.max_num_contacts, expected_max_contacts)

        G_matrix, h_vector = collision_limit.compute_qp_inequalities(self.configuration, time_step=1e-3)

        # Ensure that all constraints are above the relaxation bound
        self.assertTrue(np.all(h_vector >= bound_relaxation))

        # Validate the shape of the inequality constraint matrices
        self.assertEqual(G_matrix.shape, (expected_max_contacts, self.model.nv))
        self.assertEqual(h_vector.shape, (expected_max_contacts,))

    def test_contact_normal_jacobian_compatibility(self):
        """Test the compatibility of the contact normal Jacobian computation with MuJoCo."""
        model = load_robot_description("ur5e_mj_description")
        num_dof = model.nv

        # Set options to enable elliptic cones and dense Jacobians
        model.opt.cone = mujoco.mjtCone.mjCONE_ELLIPTIC
        model.opt.jacobian = mujoco.mjtJacobian.mjJAC_DENSE

        # Disable unnecessary constraints
        model.opt.disableflags |= mujoco.mjtDisableBit.mjDSBL_EQUALITY
        model.opt.disableflags |= mujoco.mjtDisableBit.mjDSBL_FRICTIONLOSS
        model.opt.disableflags |= mujoco.mjtDisableBit.mjDSBL_LIMIT

        # Set contact dimensionality to 1 (normals only)
        model.geom_condim[:] = 1

        data = mujoco.MjData(model)

        # Set a specific configuration with known contacts
        qpos_with_contacts = np.array([-1.5708, -1.5708, 3.01632, -1.5708, -1.5708, 0])
        data.qpos = qpos_with_contacts
        mujoco.mj_forward(model, data)
        self.assertGreater(data.ncon, 1)

        for contact_index in range(data.ncon):
            # Retrieve MuJoCo's contact normal Jacobian\n            mujoco_contact = data.contact[contact_index]\n            start = mujoco_contact.efc_address * num_dof\n            end = start + num_dof\n            mujoco_jacobian = data.efc_J[start:end]\n\n            # Compute the contact normal Jacobian manually\n            contact_normal = mujoco_contact.frame[:3]\n            contact_distance = mujoco_contact.dist\n            contact_fromto = np.empty(6, dtype=np.float64)\n            contact_fromto[3:] = mujoco_contact.pos - 0.5 * contact_distance * contact_normal\n            contact_fromto[:3] = mujoco_contact.pos + 0.5 * contact_distance * contact_normal\n            contact = Contact(\n                dist=contact_distance,\n                fromto=contact_fromto,\n                geom1=mujoco_contact.geom1,\n                geom2=mujoco_contact.geom2,\n                distmax=np.inf,\n            )\n            manual_jacobian = compute_contact_normal_jacobian(model, data, contact)\n\n            # Validate that the computed Jacobian matches MuJoCo's
            np.testing.assert_allclose(manual_jacobian, mujoco_jacobian, atol=1e-7)


if __name__ == "__main__":
    absltest.main()