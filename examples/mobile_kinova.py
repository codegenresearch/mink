from dataclasses import dataclass, field\nfrom pathlib import Path\n\nimport mujoco\nimport mujoco.viewer\nimport numpy as np\nfrom dm_control.viewer import user_input\nfrom loop_rate_limiters import RateLimiter\n\nimport mink\n\n_HERE = Path(__file__).parent\n_XML = _HERE / "stanford_tidybot" / "scene_mobile_kinova.xml"\n\n@dataclass\nclass KeyCallback:\n    fix_base: bool = False\n    pause: bool = False\n\n    def __call__(self, key: int) -> None:\n        if key == user_input.KEY_ENTER:\n            self.fix_base = not self.fix_base\n        elif key == user_input.KEY_SPACE:\n            self.pause = not self.pause\n\nif __name__ == "__main__":\n    # Load model and data\n    model = mujoco.MjModel.from_xml_path(_XML.as_posix())\n    data = mujoco.MjData(model)\n\n    # Define joints to control\n    joint_names = [\n        # Base joints\n        "joint_x",\n        "joint_y",\n        "joint_th",\n        # Arm joints\n        "joint_1",\n        "joint_2",\n        "joint_3",\n        "joint_4",\n        "joint_5",\n        "joint_6",\n        "joint_7",\n    ]\n    dof_ids = np.array([model.joint(name).id for name in joint_names])\n    actuator_ids = np.array([model.actuator(name).id for name in joint_names])\n\n    # Initialize configuration\n    configuration = mink.Configuration(model)\n\n    # Define tasks\n    end_effector_task = mink.FrameTask(\n        frame_name="pinch_site",\n        frame_type="site",\n        position_cost=1.0,\n        orientation_cost=1.0,\n        lm_damping=1.0,\n    )\n\n    # Posture cost focuses on minimizing rotation when moving the base\n    posture_cost = np.zeros((model.nv,))\n    posture_cost[2] = 1e-3\n    posture_task = mink.PostureTask(model, cost=posture_cost)\n\n    # Immobile base cost minimizes movement in xy plane and minimizes rotation\n    immobile_base_cost = np.zeros((model.nv,))\n    immobile_base_cost[:2] = 100\n    immobile_base_cost[2] = 1e-3\n    damping_task = mink.DampingTask(model, immobile_base_cost)\n\n    tasks = [\n        end_effector_task,\n        posture_task,\n    ]\n\n    limits = [\n        mink.ConfigurationLimit(model),\n    ]\n\n    # IK settings\n    solver = "quadprog"\n    pos_threshold = 1e-4\n    ori_threshold = 1e-4\n    max_iters = 20\n    frequency = 200.0  # Consistent frequency setting\n\n    key_callback = KeyCallback()\n\n    with mujoco.viewer.launch_passive(\n        model=model,\n        data=data,\n        show_left_ui=False,\n        show_right_ui=False,\n        key_callback=key_callback,\n    ) as viewer:\n        mujoco.mjv_defaultFreeCamera(model, viewer.cam)\n\n        mujoco.mj_resetDataKeyframe(model, data, model.key("home").id)\n        configuration.update(data.qpos)\n        posture_task.set_target_from_configuration(configuration)\n        mujoco.mj_forward(model, data)\n\n        # Initialize the mocap target at the end-effector site\n        mink.move_mocap_to_frame(model, data, "pinch_site_target", "pinch_site", "site")\n\n        rate = RateLimiter(frequency=frequency, warn=True)  # Added warning functionality\n        dt = rate.period\n        t = 0.0\n\n        while viewer.is_running():\n            # Update task target\n            T_wt = mink.SE3.from_mocap_name(model, data, "pinch_site_target")\n            end_effector_task.set_target(T_wt)\n\n            # Compute velocity and integrate into the next configuration\n            for i in range(max_iters):\n                if key_callback.fix_base:\n                    vel = mink.solve_ik(\n                        configuration,\n                        [*tasks, damping_task],\n                        dt=rate.dt,\n                        solver=solver,\n                        damping=1e-3,\n                    )\n                else:\n                    vel = mink.solve_ik(\n                        configuration,\n                        tasks,\n                        dt=rate.dt,\n                        solver=solver,\n                        damping=1e-3,\n                    )\n                configuration.integrate_inplace(vel, rate.dt)\n\n                # Exit condition\n                pos_achieved = True\n                ori_achieved = True\n                err = end_effector_task.compute_error(configuration)\n                pos_achieved &= bool(np.linalg.norm(err[:3]) <= pos_threshold)\n                ori_achieved &= bool(np.linalg.norm(err[3:]) <= ori_threshold)\n                if pos_achieved and ori_achieved:\n                    break\n\n            if not key_callback.pause:\n                data.ctrl[actuator_ids] = configuration.q[dof_ids]\n                mujoco.mj_step(model, data)\n            else:\n                mujoco.mj_forward(model, data)\n\n            # Visualize at fixed FPS\n            viewer.sync()\n            rate.sleep()\n            t += dt\n