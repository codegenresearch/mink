from pathlib import Path\n\nimport mujoco\nimport mujoco.viewer\nimport numpy as np\nfrom loop_rate_limiters import RateLimiter\n\nimport mink\n\n# Define constants for better readability and consistency\nHERE = Path(__file__).parent\nXML_PATH = HERE / "universal_robots_ur5e" / "scene.xml"\nFREQUENCY = 500.0\nPOSITION_THRESHOLD = 1e-4\nORIENTATION_THRESHOLD = 1e-4\nMAX_ITERATIONS = 20\nSOLVER = "quadprog"\n\n\nif __name__ == "__main__":\n    # Load the model and data\n    model = mujoco.MjModel.from_xml_path(XML_PATH.as_posix())\n    data = mujoco.MjData(model)\n\n    # Setup Inverse Kinematics (IK)\n    configuration = mink.Configuration(model)\n\n    # Define tasks for the end-effector\n    tasks = [\n        mink.FrameTask(\n            frame_name="attachment_site",\n            frame_type="site",\n            position_cost=1.0,\n            orientation_cost=1.0,\n            lm_damping=1.0,\n        ),\n    ]\n\n    # Enable collision avoidance between wrist_3_link and floor/wall\n    wrist_3_geoms = mink.get_body_geom_ids(model, model.body("wrist_3_link").id)\n    collision_pairs = [\n        (wrist_3_geoms, ["floor", "wall"]),\n    ]\n\n    # Define limits for configuration and collision avoidance\n    limits = [\n        mink.ConfigurationLimit(model=configuration.model),\n        mink.CollisionAvoidanceLimit(\n            model=configuration.model,\n            geom_pairs=collision_pairs,\n        ),\n    ]\n\n    # Define velocity limits for each joint\n    max_velocities = {\n        "shoulder_pan": np.pi,\n        "shoulder_lift": np.pi,\n        "elbow": np.pi,\n        "wrist_1": np.pi,\n        "wrist_2": np.pi,\n        "wrist_3": np.pi,\n    }\n    velocity_limit = mink.VelocityLimit(model, max_velocities)\n    limits.append(velocity_limit)\n\n    # Get the mocap target ID\n    mid = model.body("target").mocapid[0]\n\n    # Initialize the model to the home keyframe\n    mujoco.mj_resetDataKeyframe(model, data, model.key("home").id)\n    configuration.update(data.qpos)\n    mujoco.mj_forward(model, data)\n\n    # Initialize the mocap target at the end-effector site\n    mink.move_mocap_to_frame(model, data, "target", "attachment_site", "site")\n\n    # Initialize the rate limiter\n    rate = RateLimiter(frequency=FREQUENCY, warn=False)\n\n    # Launch the viewer\n    with mujoco.viewer.launch_passive(\n        model=model, data=data, show_left_ui=False, show_right_ui=False\n    ) as viewer:\n        mujoco.mjv_defaultFreeCamera(model, viewer.cam)\n        viewer.opt.frame = mujoco.mjtFrame.mjFRAME_SITE\n\n        while viewer.is_running():\n            # Update task target\n            T_wt = mink.SE3.from_mocap_name(model, data, "target")\n            tasks[0].set_target(T_wt)\n\n            # Compute velocity and integrate into the next configuration\n            for _ in range(MAX_ITERATIONS):\n                vel = mink.solve_ik(\n                    configuration, tasks, rate.dt, SOLVER, damping=1e-3, limits=limits\n                )\n                configuration.integrate_inplace(vel, rate.dt)\n                err = tasks[0].compute_error(configuration)\n                pos_achieved = np.linalg.norm(err[:3]) <= POSITION_THRESHOLD\n                ori_achieved = np.linalg.norm(err[3:]) <= ORIENTATION_THRESHOLD\n                if pos_achieved and ori_achieved:\n                    break\n\n            # Update control and step the simulation\n            data.ctrl = configuration.q\n            mujoco.mj_step(model, data)\n\n            # Visualize at fixed FPS\n            viewer.sync()\n            rate.sleep()\n