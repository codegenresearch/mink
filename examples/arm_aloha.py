from pathlib import Path\\n\\nimport mujoco\\nimport mujoco.viewer\\nimport numpy as np\\nfrom loop_rate_limiters import RateLimiter\\n\\nimport mink\\n\\n_HERE = Path(__file__).parent\\n_XML = _HERE / "aloha" / "scene.xml"\\n\\n# Single arm joint names.\\n_JOINT_NAMES = [\\n    "waist",\\n    "shoulder",\\n    "elbow",\\n    "forearm_roll",\\n    "wrist_angle",\\n    "wrist_rotate"\\n]\\n\\n# Single arm velocity limits, taken from:\\n# https://github.com/Interbotix/interbotix_ros_manipulators/blob/main/interbotix_ros_xsarms/interbotix_ros_xsarm_descriptions/urdf/vx300s.urdf.xacro\\n_VELOCITY_LIMITS = {k: np.pi for k in _JOINT_NAMES}\\n\\nif __name__ == "__main__":\\n    model = mujoco.MjModel.from_xml_path(_XML.as_posix())\\n    data = mujoco.MjData(model)\\n\\n    # Get the dof and actuator ids for the joints we wish to control.\\n    joint_names = []\\n    velocity_limits = {}\\n    for prefix in ["left", "right"]:\\n        for n in _JOINT_NAMES:\\n            name = f"{prefix}/{n}"\\n            joint_names.append(name)\\n            velocity_limits[name] = _VELOCITY_LIMITS[n]\\n    dof_ids = np.array([model.joint(name).id for name in joint_names])\\n    actuator_ids = np.array([model.actuator(name).id for name in joint_names])\\n\\n    configuration = mink.Configuration(model)\\n\\n    tasks = [\\n        l_ee_task := mink.FrameTask(\\n            frame_name="left/gripper",\\n            frame_type="site",\\n            position_cost=1.0,\\n            orientation_cost=1.0,\\n            lm_damping=1.0,\\n        ),\\n        r_ee_task := mink.FrameTask(\\n            frame_name="right/gripper",\\n            frame_type="site",\\n            position_cost=1.0,\\n            orientation_cost=1.0,\\n            lm_damping=1.0,\\n        ),\\n    ]\\n\\n    # Enable collision avoidance between the following geoms:\\n    # geoms starting at subtree "right wrist" - "table",\\n    # geoms starting at subtree "left wrist"  - "table",\\n    # geoms starting at subtree "right wrist" - geoms starting at subtree "left wrist".\\n    l_wrist_geoms = mink.get_subtree_geom_ids(model, model.body("left/wrist_link").id)\\n    r_wrist_geoms = mink.get_subtree_geom_ids(model, model.body("right/wrist_link").id)\\n    frame_geoms = mink.get_body_geom_ids(model, model.body("metal_frame").id)\\n    collision_pairs = [\\n        (l_wrist_geoms, r_wrist_geoms),\\n        (l_wrist_geoms + r_wrist_geoms, frame_geoms + ["table"]),\\n    ]\\n    collision_avoidance_limit = mink.CollisionAvoidanceLimit(\\n        model=model,\\n        geom_pairs=collision_pairs,  # type: ignore\\n        minimum_distance_from_collisions=0.05,\\n        collision_detection_distance=0.1,\\n    )\\n\\n    limits = [\\n        mink.ConfigurationLimit(model=model),\\n        mink.VelocityLimit(model, velocity_limits),\\n        collision_avoidance_limit,\\n    ]\\n\\n    l_mid = model.body("left/target").mocapid[0]\\n    r_mid = model.body("right/target").mocapid[0]\\n    solver = "quadprog"\\n    pos_threshold = 1e-4\\n    ori_threshold = 1e-4\\n    max_iters = 20\\n\\n    with mujoco.viewer.launch_passive(\\n        model=model, data=data, show_left_ui=False, show_right_ui=False\\n    ) as viewer:\\n        mujoco.mjv_defaultFreeCamera(model, viewer.cam)\\n\\n        # Initialize to the home keyframe.\\n        mujoco.mj_resetDataKeyframe(model, data, model.key("neutral_pose").id)\\n        configuration.update(data.qpos)\\n        mujoco.mj_forward(model, data)\\n\\n        # Initialize mocap targets at the end-effector site.\\n        mink.move_mocap_to_frame(model, data, "left/target", "left/gripper", "site")\\n        mink.move_mocap_to_frame(model, data, "right/target", "right/gripper", "site")\\n\\n        rate = RateLimiter(frequency=200.0)\\n        while viewer.is_running():\\n            # Update task targets.\\n            l_ee_task.set_target(mink.SE3.from_mocap_name(model, data, "left/target"))\\n            r_ee_task.set_target(mink.SE3.from_mocap_name(model, data, "right/target"))\\n\\n            # Compute velocity and integrate into the next configuration.\\n            for i in range(max_iters):\\n                vel = mink.solve_ik(\\n                    configuration,\\n                    tasks,\\n                    rate.dt,\\n                    solver,\\n                    limits=limits,\\n                    damping=1e-3,\\n                )\\n                configuration.integrate_inplace(vel, rate.dt)\\n\\n                l_err = l_ee_task.compute_error(configuration)\\n                l_pos_achieved = np.linalg.norm(l_err[:3]) <= pos_threshold\\n                l_ori_achieved = np.linalg.norm(l_err[3:]) <= ori_threshold\\n                r_err = l_ee_task.compute_error(configuration)\\n                r_pos_achieved = np.linalg.norm(r_err[:3]) <= pos_threshold\\n                r_ori_achieved = np.linalg.norm(r_err[3:]) <= ori_threshold\\n                if (\\n                    l_pos_achieved\\n                    and l_ori_achieved\\n                    and r_pos_achieved\\n                    and r_ori_achieved\\n                ):\\n                    break\\n\\n            data.ctrl[actuator_ids] = configuration.q[dof_ids]\\n            mujoco.mj_step(model, data)\\n\\n            # Visualize at fixed FPS.\\n            viewer.sync()\\n            rate.sleep()\\n